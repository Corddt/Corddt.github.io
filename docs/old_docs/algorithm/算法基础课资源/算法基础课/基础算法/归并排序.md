#  归并排序
## 题目描述

>给定一个长度为 n 的整数数列。
要求使用归并排序对这个数列按照从小到大进行排序。
并输出排好序的数列。

* 输入格式

>输入共两行，第一行包含整数 n。
>
>第二行包含 n 个整数（所有整数均在 1∼10^9 范围内），表示整个数列。

* 输出格式

>输出共一行，包含 n 个整数，表示排好序的数列。

* 数据范围

>1≤n≤100000

* 输入样例

>5
>
>3 1 2 4 5

* 输出样例

>1 2 3 4 5

## 代码记忆

```cpp
// 引入标准输入输出流库
#include <iostream>

// 使用标准命名空间，避免在代码中频繁使用std::
using namespace std;

// 定义常量N，表示数组的最大长度
const int N = 1e5 + 10;

// 定义全局数组a和tmp，用于存储待排序的数列和临时数组
int a[N], tmp[N];

// 归并排序函数，参数为待排序的数组q、左边界l和右边界r
void merge_sort(int q[], int l, int r)
{
    // 如果左边界大于等于右边界，说明子数组只有一个元素或为空，直接返回
    if (l >= r) return;

    // 计算中间索引mid
    int mid = l + r >> 1;  // 使用右移操作符获取中间索引，这是一种快速计算中点的方法

    // 递归地对左右两个子数组进行归并排序
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);

    // 初始化k为0，i和j分别为左右子数组的起始索引
    int k = 0, i = l, j = mid + 1;
    // 比较左右子数组中的元素，按顺序将较小的元素放入tmp数组中
    while (i <= mid && j <= r) {
        if (q[i] <= q[j]) {
            tmp[k ++ ] = q[i ++ ];  // 将较小的元素放入tmp数组，并递增k和i
        } else {
            tmp[k ++ ] = q[j ++ ];  // 将较大的元素放入tmp数组，并递增k和j
        }
    }
    // 将剩余的较小元素放入tmp数组（如果有）
    while (i <= mid) {
        tmp[k ++ ] = q[i ++ ];  // 将剩余的元素放入tmp数组，并递增k和i
    }
    while (j <= r) {
        tmp[k ++ ] = q[j ++ ];  // 将剩余的元素放入tmp数组，并递增k和j
    }

    // 将已排序的tmp数组复制回原数组q，完成合并操作
    for (int i = l; i <= r; i ++ ) {
        q[i] = tmp[j];  // 注意这里的j应该是k，复制元素到原数组q中，并递增i和j（或k）
    }
}

// 主函数入口点
int main()
{
    // 读入整数n，表示待排序的数列长度
    int n;
    scanf("%d", &n);
    // 读入n个整数到数组a中
    for (int i = 0; i < n; i ++ ) {
        scanf("%d", &a[i]);  // 从标准输入读入一个整数，存入数组a中，并递增i
    }
    // 对数列a进行归并排序
    merge_sort(a, 0, n - 1);  // 调用归并排序函数，对数组a进行排序，左边界为0，右边界为n-1（包含n-1）
    // 输出已排序的数列a到标准输出流中
    for (int i = 0; i < n; i ++ ) {  // 从左到右依次输出每个元素到标准输出流中，并递增i
        printf("%d ", a[i]);  // 输出一个整数后加一个空格到标准输出流中，并递增i
    }
    return 0;  // 主函数返回0，表示程序正常结束
}
```

